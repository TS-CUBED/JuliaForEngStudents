{
  "hash": "80df895c28cc74187990f1b77bbdf712",
  "result": {
    "markdown": "---\ntitle: Solving ODEs and ODE systems\n---\n\n\n\nSolving Ordinary Differential Equations is one of the most common use cases for scientific computing in engineering applications. \n\nThe Julia package [DifferentialEquations.jl](https://docs.sciml.ai/DiffEqDocs/stable/) is one of the biggest selling points of the language. It offers an unparalled range of solvers, all using the same interface^[So changing the solver does not require any changes in the definition of the problem, even when moving between ODEs, DAEs and SDAEs.].\n\n## Example: 4-Element Windkessel Model\n\n\n\n\n{{< downloadthis ODEsolver.ipynb dname=ODEsolver label=\"Download Jupyter Notebook\" >}}\n\n\n\n\n\n\n\nThe windkessel model is a common model for the pressure response of the vascular system (blood circulation) to a periodic, pulsing flow waveform [@Westerhof2019].\n\nHere we are going to work with the 4-Element windkessel model [@Stergiopulos1999], comprising a flow source (time dependent flow rate), two resistors for characteristic Resistance of the near vessel (aorta), $R_{c}$, and systemic (peripheral) resistance, $R_{p}$, a compliance (capacitance) $C$, representing the blood storage capacity of the peripheral vessels, and an inductance $L_p$, representing the inertia in the proximal, large vessel, e.g., the aorta.\n\nThe pressures in this circuit - $p_{1}$ before, and $p_{2}$ after the proximal L-R element - are described by the system of ODEs:\n\n$$\n\\frac{d p_{1}}{d t}  =  - \\frac{R_{c}}{L_{p}} p_{1} + \\left( \\frac{R_{c}}{L_{p}} - \\frac{1}{R_{p} C} \\right) p_{2} \n+ R_{c} \\frac{d I(t)}{d t} + \\frac{I(t)}{C} \n$$ {#eq-wk4-1}\n\n$$\n\\frac{d p_{2}}{d t}  =  - \\frac{1}{R_{p} C} p_{2} + \\frac{I(t)}{C} \n$$ {#eq-wk4-2}\n\n<!-- Source: file:///home/thor/Documents/Research/SaxtonPhD/0D-ModellingInJulia_files/images/wk4.drawio.png, accessed: Sun Mar  5 16:01:01 2023 -->\n![4-Element Windkessel Model](./images/images_for_ODEsolver.qmd/wk4.drawio.svg){#fig-4wk}\n\n\nIn order to implement this model, we need to load the required modules. We use `DifferentialEquations`, `Plots`, and `ForwardDiff` for the time-derivative $\\frac{\\partial I}{\\partial t}$:\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nusing DifferentialEquations, ForwardDiff, Plots\n```\n:::\n\n\n\n\nThe input waveform is a generic half-period of a sine-wave with a systolic (ejection) time of $t_{syst} = 0.4 T$, with $T=1\\ \\mathrm{s}$ period-time (60 beats per minute). The dicrotic notch is modelled by running the sine into the negative for $t_{dicr} = 0.03\\ \\mathrm{s}$:\n\n\\begin{equation}\n    I = \n    \\begin{cases}\n        I_{min} + (I_{max} - I_{min})  \\sin \\left(\\frac{\\pi}{t_{syst}} t \\right) & \\text{if } t < (t_{syst} + t_{dicr})\\\\\n        I_{min} & \\text{else} \n    \\end{cases}\n\\end{equation}\n\n\nIn Julia, this function is implemented as^[Note that we use type specifications to define the parameters. Julia does suffer in performance, when untyped global variables are used, since these break type stability in the multiple dispatch. Making these parameter constant fixes their type. We should really be using these parameters in the function definition, or use a lambda function. But a lambda function is slower than typed variables.]:\n\n::: {.cell execution_count=3}\n``` {.julia .cell-code}\n# max and min volume flow in ml/s\nmax_i::Float64 = 425\nmin_i::Float64 = 0.0\n\n# period time\nT::Float64 = 1.0\n\n# Syst. Time in s\nsystTime::Float64 = 2 / 5 * T\n\n# Dicrotic notch time in s\ndicrTime::Float64 = 0.03\n\nfunction I(t)\n    # implicit conditional using boolean multiplicator\n    # sine waveform\n    t = t - T * (t รท T)\n\n    return ((max_i - min_i) * sin(pi / systTime * (t))\n            * (t < (systTime + dicrTime) )\n            + min_i)\nend \n```\n:::\n\n\nWe can quickly plot this function in @fig-igen.\n\n::: {.cell execution_count=4}\n``` {.julia .cell-code}\nplotTime = LinRange(0,1,100)\n\nplot(plotTime, I.(plotTime),\n     xlabel = \"t [s]\", ylabel = \"I [ml s<sup>-1</sup>]\", label = \"Outflow\") \n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n![Generic waveform, representing ejection of blood from left ventricle in the aorta, including dicrotic notch (backflow at valve closure).](ODEsolver_files/figure-pdf/fig-igen-output-1.svg){#fig-igen fig-pos='H'}\n:::\n:::\n\n\nThe definition of the ODEs @eq-wk4-1 and @eq-wk4-2 is done as a function with parameters `dP` and `P`, for $\\frac{d p_{1,2}}{d t}$, and $p_{1,2}$, respectively^[`P` is a vector of values, actually, as is `dP`.] \n\n::: {.cell execution_count=5}\n``` {.julia .cell-code}\nfunction wk4(dP, P, params, t)\n\n    Rc, Rp, C, Lp = params\n\n    dP[1] = (\n        -Rc / Lp * P[1]\n        + (Rc / Lp - 1 / Rp / C) * P[2]\n        + Rc * ForwardDiff.derivative(I, t)\n        + I(t) / C\n        )\n\n    dP[2] = -1 / Rp / C * P[2] + I(t) / C\n\n    return dP[1], dP[2]\n\nend\n```\n:::\n\n\nWe define the parameters, initial conditions, and time span for the integration:\n\n::: {.cell execution_count=6}\n``` {.julia .cell-code}\nRc = 0.03\nRp = 1.0\nC  = 2.0\nLp = 0.02\n\ntspan = (0, 10)\n\nparams = [Rc, Rp, C, Lp]\n\nP0 = zeros(2)\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```\n2-element Vector{Float64}:\n 0.0\n 0.0\n```\n:::\n:::\n\n\nAnd define the ODE problem and solve it^[We use the Dormand-Prince solver `DP5` here, because that is the same algorithm that Matlab's `ode45` uses. DifferentialEquations.jl has a multitude of other solvers that may perform better. Play around with these.]. We will time the run using the `@time` macro:\n\n::: {.cell execution_count=7}\n``` {.julia .cell-code}\nprob = ODEProblem(wk4, P0, tspan, params)\n\n@time sol = solve(prob, DP5(), reltol=1e-9);\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  6.863921 seconds (10.95 M allocations: 793.162 MiB, 11.05% gc time, 99.97% compilation time)\n```\n:::\n:::\n\n\nLooking at this run time, we see that the run is slower than the Matlab run^[See below. What happened here? Doesn't everybody say how much faster Julia is than Matlab?]. Looking at the details of the benchmark times, we see that most of that time has been used on compilation. So when we re-run the solver, it should take less time:\n\n::: {.cell execution_count=8}\n``` {.julia .cell-code}\n@time sol = solve(prob, DP5(), reltol=1e-9);\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  0.001543 seconds (2.95 k allocations: 252.766 KiB)\n```\n:::\n:::\n\n\nAnd indeed, the run time is now one order of magnitude faster than the Matlab times shown in @sec-odePM.\n\nWe can plot the solution in @fig-wk4-sol using the special plot recipe for ODE solutions:\n\n::: {.cell execution_count=9}\n``` {.julia .cell-code}\nplot(sol,\n     label = [\"p1\" \"p2\"],\n     xlabel = \"t [s]\",\n     ylabel = \"p [mm<sub>Hg</sub>]\",\n     tspan=(9,10))\n```\n\n::: {.cell-output .cell-output-display execution_count=10}\n![Solution of 4-element windkessel model using Julia's DifferentialEquations.jl](ODEsolver_files/figure-pdf/fig-wk4-sol-output-1.svg){#fig-wk4-sol fig-pos='H'}\n:::\n:::\n\n\n### Comparison to Python and Matlab {#sec-odePM}\n\nFor those coming from Python or Matlab, let's have a look at how this problem can be solved in these two languages and compare to the Julia version.\n\nSwitch between the languages using the tabs below:\n\n::: {.panel-tabset}\n### Python\n\n\n\n\n{{< downloadthis wk4_python.py dname=wk4_python label=\"Download Python Code\" >}}\n\n\n\n\n\n\n\n```{.python include=\"wk4_python.py\"}\n```\n\nRuntime for this code is (timed using `time.perf.counter` in Python):\n\n<!-- ```python -->\n<!-- Time elapsed: 0.7872 seconds -->\n<!-- ``` -->\n\n::: {.cell execution_count=10}\n\n::: {.cell-output .cell-output-stdout}\n```\nFirst run:\nElapsed time is 0.7973 seconds\n\nSecond run:\nElapsed time is 0.7810 seconds\n```\n:::\n:::\n\n\n### MATLAB\n\n\n\n\n{{< downloadthis wk4_matlab.m dname=wk4_matlab label=\"Download Matlab Code\" >}}\n\n\n\n\n\n\n\n```{.matlab include=\"wk4_matlab.m\"}\n```\n\nRuntime for this code is (timed using `tic` `toc` in Matlab)^[Same code in Octave, the free open-source version of Matlab runs in 3 seconds. Current versions of Matlab have improved runtime by partial just-in-time compilation. Note that the first run in Matlab also takes an order of magnitude longer, which is most likely due to Matlab optimising the solver to the problem.], which is a bit more than an order of magnitude slower than Julia:\n\n<!-- ```octave -->\n<!-- Elapsed time is 0.018172 seconds. -->\n<!-- ``` -->\n\n::: {.cell execution_count=11}\n\n::: {.cell-output .cell-output-stdout}\n```\nFirst run:\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nElapsed time is 0.363712 seconds.\n\nSecond run:\nElapsed time is 0.032150 seconds.\n```\n:::\n:::\n\n\n:::\n\nSo in this case, Julia is one order of magitude faster than Matlab and around 500x faster than Python^[I have tried using PyPy and Cython in other cases and found that they speed up Python considerably. Unfortunately this was not the case when using SciPy and Numpy, which made the compiled Python version one order of magnitude **slower** than interpreted. There seems to be a problem with C-calls from PyPy.] solving ODEs.\n\nPersonally, I find the Matlab code and, in particular, the Julia code easier to read.\n\n",
    "supporting": [
      "ODEsolver_files/figure-pdf"
    ],
    "filters": []
  }
}